<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flagulous</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='10' fill='%230b0d12'/%3E%3Cpath d='M12 14h28l-6 6 6 6-6 6 6 6-6 6 6 6H12Z' fill='%232b64ff'/%3E%3C/svg%3E">
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif }
    body { margin: 0; min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 16px; background: #0b0d12; color: #e8eaed }
    .page-shell { width: min(100%, 780px); margin: 0 auto; display: flex; flex-direction: column; align-items: stretch; gap: 12px; box-sizing: border-box; }
    .card { width: min(100%, 760px); max-width: 780px; background: #11151c; border: 1px solid #2a2f3a; border-radius: 20px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.35); display: flex; flex-direction: column; box-sizing: border-box; }
    h1 { margin: 0; font-size: 22px; font-weight: 600 }
    .title-row { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 12px; }
    .title-row h1 { margin: 0; flex: 1 1 0; min-width: 0; }
    .auth-row { display: flex; justify-content: flex-start; align-items: center; gap: 12px; margin-bottom: 0; flex-wrap: wrap; position: relative; }
    .profile-link { display: inline-flex; align-items: center; gap: 8px; text-decoration: none; color: inherit; opacity: 0.9; margin-left: auto; }
    .profile-avatar { width: 34px; height: 34px; border-radius: 999px; background: #1a1f2a; border: 1px solid #2a2f3a; display: inline-flex; align-items: center; justify-content: center; font-weight: 700; color: #7cec8f; overflow: hidden; }
    .profile-avatar img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .profile-panel { position: absolute; top: 48px; right: 0; min-width: 220px; padding: 12px; border-radius: 12px; background: #0e1218; border: 1px solid #2a2f3a; box-shadow: 0 12px 30px rgba(0,0,0,.45); display: none; z-index: 10100; }
    .profile-panel h3 { margin: 0 0 8px; font-size: 15px; }
    .profile-panel .profile-meta { font-size: 13px; opacity: 0.85; margin: 0 0 6px; word-break: break-word; }
    .profile-panel .profile-meta strong { font-weight: 600; }
    .flag-stage { position: relative; width: min(66vw, 380px); max-width: 380px; aspect-ratio: 4/3; margin: 16px auto; background: #0e1218; border-radius: 14px; overflow: hidden; border: 2px solid #000; box-shadow: 0 0 0 4px #fff; }
    .layer { position: absolute; inset: 0; display: none; width: 100%; height: 100%; object-fit: contain; font-size: 0; color: transparent; }
    .layer.visible { display: block }
    .full-flag { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; opacity: 0; transition: opacity 200ms ease; z-index: 10000; pointer-events: none; font-size: 0; color: transparent; }
    .full-flag.visible { opacity: 1; }
    .fireworks { position: absolute; inset: 0; pointer-events: none; display: flex; align-items: center; justify-content: center; opacity: 0; z-index: 10010; }
    .fireworks.active { opacity: 1; transition: opacity 200ms ease; }
    .fireworks span {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--color, #fff);
      opacity: 0;
      transform: translate(-50%, -50%) scale(0);
    }
    .fireworks.active span {
      animation: var(--anim, burst) 900ms ease-out forwards;
    }
    @keyframes burst {
      0% { transform: translate(0, 0) scale(0.3); opacity: 0.95; }
      45% { opacity: 1; }
      100% { transform: translate(var(--dx), var(--dy)) scale(2); opacity: 0; }
    }
    @keyframes swirl {
      0% { transform: translate(0, 0) scale(0.3) rotate(0deg); opacity: 0.95; }
      60% { opacity: 1; }
      100% { transform: translate(var(--dx), var(--dy)) scale(1.8) rotate(540deg); opacity: 0; }
    }
    @keyframes arc {
      0% { transform: translate(0, 0) scale(0.3); opacity: 0.95; }
      50% { transform: translate(var(--mx), var(--my)) scale(1.2); opacity: 1; }
      100% { transform: translate(var(--dx), var(--dy)) scale(1.8); opacity: 0; }
    }
    .flag-area { display: flex; flex-direction: column; align-items: center; gap: 6px; justify-content: center; margin: 16px 0 4px; }
    .guess-history { width: 100%; max-width: 320px; padding: 12px 14px; border-radius: 14px; border: 1px solid #2a2f3a; background: #0e1218; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02); display: flex; flex-direction: column; gap: 8px; }
    .guess-history.hidden { display: none; }
    .history-title { font-size: 12px; letter-spacing: 0.2em; text-transform: uppercase; opacity: 0.7; }
    .history-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; }
    .history-list li { font-size: 14px; display: flex; justify-content: space-between; align-items: center; gap: 8px; padding-bottom: 6px; border-bottom: 1px solid rgba(255, 255, 255, 0.12); }
    .history-list li:last-child { border-bottom: none; padding-bottom: 0; }
    .history-info { display: flex; align-items: center; gap: 8px; width: 100%; flex-wrap: wrap; }
    .history-name { font-weight: 600; }
    .history-direction { font-size: 12px; padding: 2px 6px; border-radius: 999px; border: 1px solid rgba(255, 255, 255, 0.25); opacity: 0.85; background: rgba(255, 255, 255, 0.05); display: inline-flex; }
    .history-status { font-size: 12px; opacity: 0.85; white-space: nowrap; }
    .history-status.correct { color: #7cec8f; }
    .history-status.miss { color: #ff8e8e; }
    .history-empty { opacity: 0.6; font-size: 13px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between }
    .date-row { margin-top: 8px; gap: 12px; justify-content: center; flex-direction: column; align-items: center; text-align: center; }
    .give-up-row { justify-content: center; }
    .archive-block { display: flex; flex-direction: column; gap: 6px; align-items: center; }
    .archive-label { font-size: 10px; letter-spacing: 0.3em; text-transform: uppercase; opacity: 0.65; }
    .nav-buttons { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
    .nav-buttons button { min-width: 120px; }
    button { background: #2b64ff; color: white; border: none; border-radius: 10px; padding: 10px 14px; font-weight: 600; cursor: pointer; min-height: 40px; }
    button:disabled{ opacity: .55; cursor: not-allowed }
    .pill { padding: 6px 10px; border: 1px solid #2a2f3a; border-radius: 999px; font-size: 12px; opacity: .85 }
    .tiny { font-size: 12px; opacity: .75 }
    .colors { display: flex; gap: 6px; align-items: center; margin-top: 8px }
    .swatch { width: 16px; height: 16px; border-radius: 4px; border: 1px solid #0006 }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
    .guess-actions { margin-top: 12px; justify-content: flex-start; gap: 10px; width: 100%; }
    .guess-row { display: grid; grid-template-columns: minmax(0, 1fr) auto; column-gap: 12px; row-gap: 8px; margin-top: 10px; align-items: stretch; width: 100%; }
    body.game-finished .guess-row {
      display: none !important;
    }
    .autosuggest { position: relative; min-width: 0; width: 100%; }
    #guessInput { box-sizing: border-box; width: 100%; }
    .guess-row button { min-width: 120px; justify-self: end; }
    #shareResults {
      display: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-weight: 700;
      letter-spacing: 0.05em;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, #1b2a5f 0%, #2f46a9 45%, #4931a9 70%, #1c1c48 100%);
      box-shadow: 0 10px 20px rgba(10, 16, 34, 0.5);
      text-transform: uppercase;
      font-size: 12px;
      min-width: 0;
      margin: 0 auto;
      line-height: 1.2;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background-size: 200% 200%;
      animation: shimmer 2.6s ease-in-out infinite;
    }
    .share-row { justify-content: center; align-items: center; width: 100%; gap: 8px; flex-direction: column; }
    .share-row button {
      width: min(100%, 240px);
    }
    .share-note {
      min-height: 1.5em;
      font-size: 11px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.6;
      margin-top: 2px;
      transition: opacity 200ms ease;
    }
    .share-note.visible {
      opacity: 1;
    }
    .leaderboard-link {
      display: none;
      background: linear-gradient(135deg, #2b5ca9 0%, #7cec8f 70%);
      color: #030b05;
      border: 1px solid rgba(12, 30, 9, 0.25);
      border-radius: 999px;
      padding: 8px 20px;
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      cursor: pointer;
      text-decoration: none;
      font-weight: 700;
      box-shadow: 0 6px 14px rgba(11, 78, 20, 0.35);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
    }
    .auth-link { display: inline-flex; justify-content: center; align-self: center; margin: 18px auto 24px; text-align: center; color: #7cec8f; font-weight: 600; text-decoration: none; width: fit-content; }
    .auth-link.sign-in { margin: 0; padding: 0; background: none; font-weight: 600; }
    .flag-label { text-align: center; font-size: 11px; letter-spacing: 0.4em; text-transform: uppercase; opacity: 0.7; margin-top: 12px; }
    .correct-row { text-align: center; font-size: 18px; letter-spacing: 0.3em; text-transform: uppercase; opacity: 0.8; margin-top: 8px; min-height: 18px; font-weight: 700; }
    .layer-info { text-align: center; font-size: 12px; letter-spacing: 0.3em; text-transform: uppercase; opacity: 0.65; }
    input[type="text"] { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #0b0f16; color: inherit }
    input[type="text"]:disabled { opacity: .6 }
    .suggestion-list { position: absolute; top: calc(100% + 4px); left: 0; right: 0; background: rgba(17,21,28,0.95); border: 1px solid #2a2f3a; border-radius: 10px; max-height: 220px; overflow-y: auto; box-shadow: 0 12px 30px rgba(0,0,0,.55); display: none; z-index: 1100; }
    .suggestion-list button { width: 100%; border: none; background: transparent; color: inherit; padding: 8px 12px; text-align: left; font-size: 14px; cursor: pointer }
    .suggestion-list button:hover, .suggestion-list button:focus-visible { background: #1f2430; outline: none }
    .feedback { min-height: 20px; margin-top: 8px; font-size: 14px; color: #90c1ff; text-align: center; }
    .mobile-flash { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; text-transform: none; font-weight: 700; letter-spacing: 0; font-size: 64px; color: #ff8e8e; background: rgba(0, 0, 0, 0.6); opacity: 0; pointer-events: none; transition: opacity 150ms ease; z-index: 1250; padding: 12px; box-sizing: border-box; }
    .mobile-flash.visible { opacity: 1; }
    @keyframes shimmer {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    @media (min-width: 721px) {
      .guess-history { margin: 0 auto; }
    }

    @media (max-width: 720px) {
      body { align-items: flex-start; padding: 0 0 20px; justify-content: flex-start; }
      .card { padding: 18px; width: 100%; max-width: 100%; border-radius: 0; margin: 0; }
      .row { flex-direction: column; align-items: stretch; gap: 12px; }
      .controls { flex-direction: column; }
      .controls button { width: 100%; }
      .guess-row { grid-template-columns: 1fr; column-gap: 0; }
      .guess-row button { width: 100%; margin-left: 0; justify-self: stretch; }
      .flag-stage { margin: 12px auto; }
      .colors { flex-wrap: wrap; }
      .profile-link { margin-left: 0; }
      .profile-panel { right: 0; left: 0; top: 56px; }
      #shareResults { width: auto; }
      .flag-area { flex-direction: column; align-items: flex-end; order: 1; }
      .flag-area .flag-stage { margin-left: auto; }
      .guess-history { order: 3; width: 100%; }
      .title-row { flex-wrap: nowrap; }
      .guess-row { order: 2; }
      .guess-actions { order: 4; }
      .feedback { order: 5; }
      .colors { order: 6; }
      .share-row { order: 7; }
      .date-row { order: 9; }
      .page-shell { width: 100%; padding: 0 12px 12px; margin: 0; }
      .auth-link { width: 100%; margin: 16px 0 24px; }
      .controls { justify-content: flex-start; }
    }
    @media (max-width: 480px) {
      .card { padding: 14px; }
      button { padding: 10px; font-size: 13px; }
      .autosuggest { max-width: 100%; }
      .suggestion-list { top: calc(100% + 4px); }
    }
    @media (max-width: 900px) {
      .flag-area { flex-direction: column; align-items: center; }
      .guess-history { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="page-shell">
    <div class="card">
    <div class="title-row">
      <h1>Flagulous</h1>
      <div class="auth-row">
        <a id="authSignIn" class="auth-link sign-in" href="#">Sign In</a>
        <a id="profileLink" class="profile-link" href="/profile.html" style="display:none;">
          <span class="profile-avatar" id="profileAvatar">?</span>
        </a>
      </div>
    </div>
    <div class="flag-label">GUESS THE FLAG</div>
    <div class="flag-area">
      <div class="flag-stage" id="stage">
        <img id="fullFlag" class="full-flag" aria-hidden="true" />
        <div id="fireworks" class="fireworks" aria-hidden="true">
          <span></span>
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
      <div class="correct-row" id="correctMessage"></div>
      <div class="layer-info" id="layerInfo">NO LAYERS SHOWN</div>
      <div class="colors" id="colors"></div>
    </div>
    <div class="guess-row">
      <div class="autosuggest" id="guess-autosuggest">
        <input id="guessInput" type="text" placeholder="Enter your first guess" autocomplete="off" spellcheck="false" />
        <div class="suggestion-list" id="suggestions" role="listbox" aria-label="Matching countries"></div>
      </div>
      <button id="submitGuess" disabled>Submit Guess</button>
    </div>
    <div class="guess-history hidden" id="guessHistory">
      <div class="history-title">Previous guesses</div>
      <ol class="history-list" id="guessHistoryList"></ol>
    </div>
    <div class="feedback" id="feedback"></div>
    <div class="row share-row">
      <button id="shareResults">Share Results</button>
      <button id="leaderboardLink" class="leaderboard-link" type="button">View Leaderboard</button>
      <div class="share-note" id="shareLinkMessage" aria-live="polite"></div>
    </div>
    <div class="row date-row">
      <div class="pill" id="dateDisplay">Date: ‚Äì</div>
      <div class="archive-block">
        <div class="archive-label">PLAY THE ARCHIVE:</div>
        <div class="nav-buttons">
          <button id="prevDate">‚Üê Previous Date</button>
          <button id="nextDate">Next Date ‚Üí</button>
        </div>
      </div>
    </div>
    <div class="controls guess-actions give-up-row">
      <button id="giveUp">Give Up</button>
    </div>
  </div>
  <a id="authSignOut" class="auth-link" href="#" style="display:none;">Sign out</a>
</div>
  <div id="mobileFlash" class="mobile-flash" aria-live="polite">‚úò</div>
  <script src="/firebase-config.js"></script>
  <script type="module" src="/firebase-auth.js"></script>
  <script type="module">
    import { getFirestore, doc, setDoc, serverTimestamp, getDoc, updateDoc, increment, collection, arrayUnion } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js';
    import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js';

    const firestore = getFirestore();
    const auth = getAuth();
    let firebaseUser = null;
    onAuthStateChanged(auth, async (user) => {
      firebaseUser = user;
      if (currentSharePayload) {
        void recordShareForPayload(currentSharePayload);
      }
      await hydrateHistoryClearedAt(firebaseUser ? firebaseUser.uid : null);
      applySavedResult();
      void processPendingShareLink();
    });

    const MAX_GUESSES = 6;
    const LOCAL_RESULT_PREFIX = 'flagly-result-';
    const LAST_DATE_KEY = 'flagly-last-date';
    const LAST_INDEX_KEY = 'flagly-last-index';
    const HISTORY_CLEARED_KEY = 'flagly-history-cleared-at';

    const stage = document.getElementById('stage');
    const progress = document.getElementById('progress');
    const colorsBox = document.getElementById('colors');
    const feedback = document.getElementById('feedback');
    const guessInput = document.getElementById('guessInput');
    const btnSubmitGuess = document.getElementById('submitGuess');
    const guessRow = document.querySelector('.guess-row');
    const suggestions = document.getElementById('suggestions');
    const autosuggest = document.getElementById('guess-autosuggest');
    const finalFlag = document.getElementById('fullFlag');
    const fireworks = document.getElementById('fireworks');
    const guessHistoryList = document.getElementById('guessHistoryList');
    const guessHistoryPanel = document.getElementById('guessHistory');
    const btnGiveUp = document.getElementById('giveUp');
    const dateDisplay = document.getElementById('dateDisplay');
    const btnPrevDate = document.getElementById('prevDate');
    const btnNextDate = document.getElementById('nextDate');
    const btnShare = document.getElementById('shareResults');
    const correctMessage = document.getElementById('correctMessage');
    const layerInfo = document.getElementById('layerInfo');
    const mobileFlash = document.getElementById('mobileFlash');
    const shareLinkMessage = document.getElementById('shareLinkMessage');
    const leaderboardLink = document.getElementById('leaderboardLink');

    let manifest = {};
    let order = [];
    let idx = -1;
    let current = null;
    let visibleCount = 0;
    let attempts = 0;
    let awaitingGuess = false;
    let roundSolved = false;
    let roundFinished = false;
    const GUESS_MIN_LENGTH = 3;
    const SUGGESTION_LIMIT = 8;
    const ORDINALS = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];
    let countryOptions = [];
    let selectedSuggestion = null;
    let guessHistory = [];
    let guessedThisRound = new Set();
    let pendingFullFlagSrc = '';
    let pendingFullFlagAlt = '';
    let countryLocations = {};

    const DAY_MS = 24 * 60 * 60 * 1000;
    const DAYS_BEFORE = 500;
    const DAYS_AFTER = 500;
    const TOTAL_WINDOW = DAYS_BEFORE + DAYS_AFTER + 1;
    const SCHEDULE_SEED_ISO = '2024-01-01';
    const SCHEDULE_SEED_VALUE = Number(SCHEDULE_SEED_ISO.replace(/-/g, '')) || 1337;
    const MOBILE_BREAKPOINT_QUERY = '(max-width: 720px)';

    function isMobileViewport() {
      if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') return false;
      return window.matchMedia(MOBILE_BREAKPOINT_QUERY).matches;
    }

    function shouldBlurAfterGuess() {
      return isMobileViewport();
    }

    function getLocalMidnight(date = new Date()) {
      if (!(date instanceof Date)) return null;
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }

    let todayLocalMidnight = null;
    let startDate = null;
    const TODAY_INDEX = DAYS_BEFORE;

    const COUNTRY_NAME_OVERRIDES = {
      cg: 'Republic of the Congo',
      cd: 'Democratic Republic of the Congo',
    };
    const SHARE_PARAM = 'shareId';
    const SHARE_PENDING_KEY = 'flagly-share-link';
    const SHARE_PAYLOAD_PREFIX = 'flagly-share-payload-';
    const INDEX_PARAM = 'idx';
    const ARCHIVE_PARAM = 'archive';
    const shareRecordedIds = new Set();
    const MAX_SHARE_ID_LENGTH = 8;
    let currentSharePayload = null;
    let shareLinkInProgress = false;
    let shareLinkTimeoutId = null;
    let initialShareId = null;

    function isoToName(cc) {
      try {
        const upper = cc.toUpperCase();
        const override = COUNTRY_NAME_OVERRIDES[cc];
        if (override) return override;
        return new Intl.DisplayNames(['en'], { type: 'region' }).of(upper) || upper;
      } catch {
        return cc.toUpperCase();
      }
    }

    function toDateOnly(date) {
      if (!(date instanceof Date)) return null;
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
    }

    function addDays(date, days) {
      if (!(date instanceof Date)) return null;
      return new Date(date.getTime() + days * DAY_MS);
    }

    function clampIndex(value) {
      if (!order.length) return 0;
      const maxAllowed = Math.min(order.length - 1, TODAY_INDEX);
      if (value < 0) return 0;
      if (value > maxAllowed) return maxAllowed;
      return Math.min(value, maxAllowed);
    }

    function indexToDate(index) {
      return new Date(startDate.getTime() + index * DAY_MS);
    }

    function captureGuessHistorySnapshot() {
      return guessHistory.map((entry) => ({
        name: entry.name || '',
        cc: entry.cc || '',
        correct: !!entry.correct,
        direction: entry.direction || null,
      }));
    }

    function hydrateGuessHistory(entries) {
      if (!Array.isArray(entries)) {
        guessHistory = [];
        guessedThisRound = new Set();
        renderGuessHistory();
        return;
      }
      guessHistory = entries.map((entry) => ({
        name: entry.name || '',
        cc: entry.cc || '',
        correct: !!entry.correct,
        direction: entry.direction || null,
      }));
      guessedThisRound = new Set(guessHistory.map((entry) => entry.cc).filter(Boolean));
      renderGuessHistory();
    }

    function buildPersistentPayload(dateKey, status) {
      return {
        date: dateKey,
        country: current?.cc || '',
        status,
        attempts,
        timestamp: Date.now(),
        guessHistory: captureGuessHistorySnapshot(),
      };
    }

    function persistInProgressState() {
      if (!current || idx < 0) return;
      const date = indexToDate(idx);
      if (!date) return;
      const dateKey = formatLocalDateKey(date);
      if (!dateKey) return;
      persistLocalResult(dateKey, buildPersistentPayload(dateKey, 'in-progress'));
    }

    function persistLocalResult(dateKey, payload) {
      if (typeof localStorage === 'undefined') return;
      try {
        const storageKey = `${LOCAL_RESULT_PREFIX}${dateKey}`;
        localStorage.setItem(storageKey, JSON.stringify(payload));
      } catch (err) {
        console.error('Persisting local result failed', err);
      }
    }

    function readLocalHistoryClearedAt() {
      if (typeof localStorage === 'undefined') return 0;
      try {
        const raw = localStorage.getItem(HISTORY_CLEARED_KEY);
        return raw ? Number(raw) || 0 : 0;
      } catch (err) {
        console.error('Loading history clear timestamp failed', err);
        return 0;
      }
    }

    let localHistoryClearedAt = readLocalHistoryClearedAt();
    let remoteHistoryClearedAt = 0;

    function setLocalHistoryClearedAt(value) {
      if (typeof localStorage === 'undefined' || value == null) return;
      try {
        localStorage.setItem(HISTORY_CLEARED_KEY, String(value));
        localHistoryClearedAt = value;
      } catch (err) {
        console.error('Storing history clear timestamp failed', err);
      }
    }

    function getEffectiveHistoryClearedAt() {
      return Math.max(localHistoryClearedAt || 0, remoteHistoryClearedAt || 0);
    }

    function removeLocalResult(dateKey) {
      if (typeof localStorage === 'undefined' || !dateKey) return;
      try {
        const storageKey = `${LOCAL_RESULT_PREFIX}${dateKey}`;
        localStorage.removeItem(storageKey);
      } catch (err) {
        console.error('Removing local result failed', err);
      }
    }

    function shouldIgnoreEntry(entry) {
      if (!entry) return false;
      const clearedAt = getEffectiveHistoryClearedAt();
      if (!clearedAt) return false;
      const timestamp = Number(entry.timestamp) || 0;
      return timestamp && timestamp <= clearedAt;
    }


    function normalizeRemoteResult(data) {
      if (!data) return null;
      const stamp = data.timestamp && typeof data.timestamp.toMillis === 'function'
        ? data.timestamp.toMillis()
        : Number(data.timestamp) || 0;
      return { ...data, timestamp: stamp };
    }


    async function hydrateHistoryClearedAt(uid) {
      remoteHistoryClearedAt = 0;
      if (!uid) return 0;
      try {
        const metaRef = doc(firestore, 'users', uid);
        const metaSnap = await getDoc(metaRef);
        const clearedAtField = metaSnap.exists() ? metaSnap.data()?.historyClearedAt : null;
        const timestamp = clearedAtField
          ? (typeof clearedAtField.toMillis === 'function'
            ? clearedAtField.toMillis()
            : Number(clearedAtField) || 0)
          : 0;
        if (timestamp) {
          remoteHistoryClearedAt = timestamp;
          setLocalHistoryClearedAt(timestamp);
        }
        return timestamp;
      } catch (err) {
        console.error('Loading history metadata failed', err);
        return 0;
      }
    }

    function loadLocalResult(dateKey) {
      if (typeof localStorage === 'undefined') return null;
      try {
        const storageKey = `${LOCAL_RESULT_PREFIX}${dateKey}`;
        const raw = localStorage.getItem(storageKey);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        return {
          ...parsed,
          timestamp: Number(parsed.timestamp) || 0,
        };
      } catch (err) {
        console.error('Loading local result failed', err);
        return null;
      }
    }

    function formatLocalDateKey(date) {
      return formatIsoDateKey(date);
    }

    function parseLocalDateKey(value) {
      if (!value) return null;
      const parsed = new Date(`${value}T00:00:00`);
      return Number.isNaN(parsed.getTime()) ? null : parsed;
    }

    function formatIsoDateKey(date) {
      if (!date) return null;
      const year = date.getUTCFullYear();
      const month = String(date.getUTCMonth() + 1).padStart(2, '0');
      const day = String(date.getUTCDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function persistLastViewedDate(date) {
      if (!date || typeof localStorage === 'undefined') return;
      try {
        const iso = formatIsoDateKey(date);
        if (!iso) return;
        localStorage.setItem(LAST_DATE_KEY, iso);
      } catch (err) {
        console.error('Storing last viewed date failed', err);
      }
    }

    function loadLastViewedDate() {
      if (typeof localStorage === 'undefined') return null;
      try {
        const raw = localStorage.getItem(LAST_DATE_KEY);
        if (!raw) return null;
        return parseLocalDateKey(raw);
      } catch (err) {
        console.error('Loading last viewed date failed', err);
        return null;
      }
    }

    function persistLastViewedIndex(value) {
      if (value == null || typeof localStorage === 'undefined') return;
      try {
        localStorage.setItem(LAST_INDEX_KEY, String(value));
      } catch (err) {
        console.error('Storing last viewed index failed', err);
      }
    }

    function loadLastViewedIndex() {
      if (typeof localStorage === 'undefined') return null;
      try {
        const raw = localStorage.getItem(LAST_INDEX_KEY);
        if (raw == null) return null;
        const parsed = Number.parseInt(raw, 10);
        return Number.isNaN(parsed) ? null : parsed;
      } catch (err) {
        console.error('Loading last viewed index failed', err);
        return null;
      }
    }

    async function saveGameResultToAccount(status) {
      if (!firebaseUser || !current || idx < 0) return;
      const date = indexToDate(idx);
      if (!date) return;
      const dateKey = date.toISOString().slice(0, 10);
      const payload = {
        date: dateKey,
        country: current.cc,
        status,
        attempts,
        timestamp: serverTimestamp(),
      };
      const localPayload = {
        ...payload,
        timestamp: Date.now(),
        guessHistory: captureGuessHistorySnapshot(),
      };
      const displayName = firebaseUser.displayName || firebaseUser.email || 'Flagulous Player';
      try {
        persistLocalResult(dateKey, localPayload);
        await setDoc(doc(firestore, 'users', firebaseUser.uid), {
          displayName,
        }, { merge: true });
        const ref = doc(firestore, 'users', firebaseUser.uid, 'results', dateKey);
        await setDoc(ref, payload, { merge: true });
      } catch (err) {
        console.error('Saving finished game failed', err);
      }
    }

    function dateDiffInDays(date) {
      const only = getLocalMidnight(date);
      const base = startDate ? getLocalMidnight(startDate) : null;
      if (!only || !base) return 0;
      return Math.floor((only.getTime() - base.getTime()) / DAY_MS);
    }

    function formatDateLabel(date) {
      try {
        return new Intl.DateTimeFormat('en', {
          weekday: 'long',
          month: 'long',
          day: 'numeric',
          year: 'numeric',
        }).format(date);
      } catch {
        return date.toISOString().slice(0, 10);
      }
    }

    function normalizeSearchText(text) {
      if (!text) return '';
      const normalized = text
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ');
      return normalized
        .replace(/\bst\.?\b/g, 'saint')
        .replace(/\bsaint\b/g, 'saint')
        .replace(/\s+/g, ' ')
        .trim();
    }

    const FIREWORKS_COLORS = ['#7cec8f', '#ffb612', '#6ea8ff', '#ff8e8e', '#f7f7f7', '#8bf0ff'];

    function showLeaderboardLink(show) {
      if (!leaderboardLink) return;
      leaderboardLink.style.display = show ? 'inline-flex' : 'none';
    }

    function hideShareButton() {
      if (!btnShare) return;
      btnShare.style.display = 'none';
      btnShare.disabled = false;
      btnShare.dataset.shareText = '';
      btnShare.dataset.shareId = '';
      btnShare.textContent = 'Share Results';
      currentSharePayload = null;
      setShareLinkMessage('');
      showLeaderboardLink(false);
    }

    const LAYER_LABELS = ['NO', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT'];

    function generateShareId() {
      if (typeof window === 'undefined') {
        return Math.random().toString(36).slice(2, 10);
      }
      const cryptoObj = window.crypto || window.msCrypto;
      if (cryptoObj && cryptoObj.randomUUID) {
        return cryptoObj.randomUUID().slice(0, MAX_SHARE_ID_LENGTH);
      }
      return Math.random().toString(36).slice(2, 2 + MAX_SHARE_ID_LENGTH);
    }

    function getShareStorageKey(dateKey) {
      return `${SHARE_PAYLOAD_PREFIX}${dateKey}`;
    }

    function loadSharePayload(dateKey) {
      if (!dateKey || typeof localStorage === 'undefined') return null;
      try {
        const raw = localStorage.getItem(getShareStorageKey(dateKey));
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err) {
        console.error('Loading share payload failed', err);
        return null;
      }
    }

    function persistSharePayload(dateKey, payload) {
      if (!dateKey || !payload || typeof localStorage === 'undefined') return;
      try {
        localStorage.setItem(getShareStorageKey(dateKey), JSON.stringify(payload));
      } catch (err) {
        console.error('Persisting share payload failed', err);
      }
    }

    function buildShareUrl(dateKey, shareId, index) {
      try {
        const url = typeof window === 'undefined' ? new URL('https://geogeo-8008a.web.app') : new URL(window.location.href);
        const base = new URL(url.origin);
        base.searchParams.set('date', dateKey);
        base.searchParams.set(SHARE_PARAM, shareId);
        if (typeof index === 'number' && Number.isFinite(index)) {
          base.searchParams.set(INDEX_PARAM, String(index));
        }
        base.searchParams.set(ARCHIVE_PARAM, '1');
        return base.toString();
      } catch {
        return 'https://geogeo-8008a.web.app';
      }
    }

    function buildSharePayload(attemptsCount, dateLabel, dateKey, index) {
      const guessWord = attemptsCount === 1 ? '1 guess' : `${attemptsCount} guesses`;
      const safeDateKey = dateKey || formatLocalDateKey(new Date());
      const stored = loadSharePayload(safeDateKey);
      const shareId = (stored && stored.shareId) ? stored.shareId : generateShareId();
      const shareUrl = buildShareUrl(safeDateKey, shareId, index);
      const payload = {
        shareId,
        attempts: attemptsCount,
        dateKey: safeDateKey,
        index: Number.isFinite(index) ? index : null,
        text: [
        '‚öë Flagulous ‚ú®',
        `üß≠ I guessed Flagulous in ${guessWord}!`,
          `üéØ Date: ${dateLabel}`,
          `‚ú® Play: ${shareUrl}`,
        ].join('\n'),
      };
      persistSharePayload(safeDateKey, payload);
      return payload;
    }

    function showShareButton(payload) {
      if (!btnShare) return;
      if (!payload) {
        hideShareButton();
        return;
      }
      currentSharePayload = payload;
      btnShare.dataset.shareText = payload.text || '';
      btnShare.dataset.shareId = payload.shareId || '';
      btnShare.style.display = 'inline-flex';
      btnShare.disabled = !payload.text;
      btnShare.textContent = 'Share Results';
      setShareLinkMessage('');
      if (firebaseUser) {
        void recordShareForPayload(payload);
      }
    }

    function setShareLinkMessage(text) {
      if (!shareLinkMessage) return;
      if (!text) {
        shareLinkMessage.classList.remove('visible');
        shareLinkMessage.textContent = '';
        return;
      }
      shareLinkMessage.textContent = text;
      shareLinkMessage.classList.add('visible');
      if (shareLinkTimeoutId) {
        clearTimeout(shareLinkTimeoutId);
      }
      shareLinkTimeoutId = window.setTimeout(() => {
        shareLinkMessage.classList.remove('visible');
      }, 3600);
    }

    async function recordShareForPayload(payload) {
      if (!payload?.shareId || !firebaseUser) return;
      if (shareRecordedIds.has(payload.shareId)) return;
      shareRecordedIds.add(payload.shareId);
      const shareRef = doc(firestore, 'shares', payload.shareId);
      const statsRef = doc(firestore, 'shareStats', firebaseUser.uid);
        const sharerName = firebaseUser.displayName || firebaseUser.email || 'Flagulous Player';
      try {
        await setDoc(shareRef, {
          shareId: payload.shareId,
          sharerUid: firebaseUser.uid,
          sharerName,
          date: payload.dateKey,
          index: payload.index ?? null,
          attempts: payload.attempts,
          timestamp: serverTimestamp(),
        }, { merge: true });
        await setDoc(statsRef, {
          displayName: sharerName,
          shareCount: increment(1),
          lastSharedAt: serverTimestamp(),
        }, { merge: true });
      } catch (err) {
        console.error('Recording share failed', err);
        shareRecordedIds.delete(payload.shareId);
      }
    }

    function updateLayerInfo() {
      if (!layerInfo) return;
      if (roundFinished) {
        layerInfo.textContent = '';
        return;
      }
      const index = Math.min(visibleCount, LAYER_LABELS.length - 1);
      const label = LAYER_LABELS[index] || String(visibleCount);
      const suffix = visibleCount === 1 ? 'LAYER' : 'LAYERS';
      layerInfo.textContent = `${label} ${suffix} SHOWN`;
    }

    function setUnderFlagMessage(text) {
      if (!correctMessage) return;
      correctMessage.textContent = text;
    }

    function flashMobileTryAgain() {
      if (!mobileFlash) return;
      if (!window.matchMedia('(max-width: 720px)').matches) return;
      mobileFlash.classList.add('visible');
      if (mobileFlash.timeoutId) {
        clearTimeout(mobileFlash.timeoutId);
      }
      mobileFlash.timeoutId = setTimeout(() => {
        mobileFlash.classList.remove('visible');
      }, 400);
    }

    function hideSuggestions() {
      if (!suggestions) return;
      suggestions.innerHTML = '';
      suggestions.style.display = 'none';
    }

    function applyResultToUI(payload, dateKey) {
      if (!payload || !payload.status) return false;
      attempts = typeof payload.attempts === 'number' ? payload.attempts : attempts;
      const name = isoToName(current.cc);
      updateProgress();
      const dateLabel = formatDateLabel(indexToDate(idx));
      const canonicalPayload = {
        ...payload,
        date: dateKey,
        country: current.cc,
        timestamp: payload.timestamp || Date.now(),
        guessHistory: captureGuessHistorySnapshot(),
      };
      persistLocalResult(dateKey, canonicalPayload);
      if (payload.status === 'in-progress') {
        attempts = typeof payload.attempts === 'number' ? payload.attempts : attempts;
        setGuessControls(true);
        setGiveUp(true);
        updateProgress();
        return true;
      }
      if (payload.status === 'solved') {
        if (correctMessage) {
          correctMessage.textContent = `CORRECT! It was ${name}`;
        }
        const resolvedDate = indexToDate(idx);
        const safeDateKey = formatLocalDateKey(resolvedDate);
        const sharePayload = buildSharePayload(attempts, dateLabel, safeDateKey, idx);
        showShareButton(sharePayload);
        if (firebaseUser) {
          void recordShareForPayload(sharePayload);
        }
        endRound(true);
        return true;
      }
      if (payload.status === 'failed') {
        feedback.textContent = '';
        hideShareButton();
        setUnderFlagMessage(`OUT OF GUESSES. THE FLAG WAS ${name}`);
        endRound(false);
        return true;
      }
      if (payload.status === 'gave-up') {
        feedback.textContent = '';
        hideShareButton();
        if (correctMessage) {
          correctMessage.textContent = `REVEALED: ${name}.`;
        }
        endRound(false);
        return true;
      }
      return false;
    }

    async function applySavedResult() {
      if (!current || idx < 0) return;
      const date = indexToDate(idx);
      if (!date) return;
      const dateKey = date.toISOString().slice(0, 10);
      let localData = loadLocalResult(dateKey);
      let appliedTimestamp = 0;
      if (localData && localData.guessHistory) {
        hydrateGuessHistory(localData.guessHistory);
      } else {
        hydrateGuessHistory([]);
      }
      if (shouldIgnoreEntry(localData)) {
        removeLocalResult(dateKey);
        localData = null;
        hydrateGuessHistory([]);
      }
      if (localData && localData.status) {
        applyResultToUI(localData, dateKey);
        appliedTimestamp = localData.timestamp || 0;
      }
      if (!firebaseUser) return;
      const ref = doc(firestore, 'users', firebaseUser.uid, 'results', dateKey);
      try {
        const snap = await getDoc(ref);
        const remoteData = snap.exists() ? normalizeRemoteResult(snap.data()) : null;
        if (remoteData && shouldIgnoreEntry(remoteData)) {
          removeLocalResult(dateKey);
          return;
        }
        if (!remoteData || !remoteData.status) {
          if (localData && firebaseUser) {
            await saveGameResultToAccount(localData.status);
          }
          return;
        }
        if (remoteData.timestamp > appliedTimestamp) {
          applyResultToUI(remoteData, dateKey);
          appliedTimestamp = remoteData.timestamp;
        } else if (localData && localData.timestamp > (remoteData?.timestamp || 0)) {
          await saveGameResultToAccount(localData.status);
        }
      } catch (err) {
        console.error('Unable to load saved result', err);
      }
    }

    function triggerFireworks() {
      if (!fireworks) return;
      fireworks.innerHTML = '';
      const animations = ['burst', 'swirl', 'arc'];
      const count = 14;
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2 + Math.random() * 0.4;
        const radius = 90 + Math.random() * 80;
        const dx = Math.cos(angle) * radius;
        const dy = Math.sin(angle) * radius;
        const anim = animations[i % animations.length];
        const span = document.createElement('span');
        span.style.setProperty('--dx', `${dx.toFixed(1)}px`);
        span.style.setProperty('--dy', `${dy.toFixed(1)}px`);
        span.style.setProperty('--mx', `${(dx * 0.55).toFixed(1)}px`);
        span.style.setProperty('--my', `${(dy * 0.55).toFixed(1)}px`);
        span.style.setProperty('--color', FIREWORKS_COLORS[i % FIREWORKS_COLORS.length]);
        span.style.setProperty('--anim', anim);
        span.style.animation = `${anim} 950ms ease-out forwards`;
        fireworks.appendChild(span);
      }
      const centerPop = document.createElement('span');
      centerPop.style.setProperty('--dx', '0px');
      centerPop.style.setProperty('--dy', '0px');
      centerPop.style.setProperty('--mx', '0px');
      centerPop.style.setProperty('--my', '0px');
      centerPop.style.setProperty('--color', '#ffffff');
      centerPop.style.setProperty('--anim', 'swirl');
      centerPop.style.animation = 'swirl 700ms ease-out forwards';
      fireworks.appendChild(centerPop);
      fireworks.classList.remove('active');
      void fireworks.offsetWidth;
      fireworks.classList.add('active');
      if (fireworks.timeoutId) {
        clearTimeout(fireworks.timeoutId);
      }
      fireworks.timeoutId = setTimeout(() => {
        fireworks.classList.remove('active');
      }, 1100);
    }

    async function shareResults() {
      if (!btnShare) return;
      const text = btnShare.dataset.shareText || '';
      if (!text) return;
      try {
        if (navigator.share) {
          await navigator.share({ text });
        } else if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          throw new Error('Sharing not supported');
        }
        btnShare.textContent = 'Shared!';
      } catch (err) {
        console.error('Share failed', err);
        btnShare.textContent = 'Copy failed';
      } finally {
        btnShare.disabled = true;
        setTimeout(() => {
          if (!btnShare) return;
          btnShare.disabled = false;
          btnShare.textContent = 'Share Results';
        }, 1400);
      }
    }

    function resetGuessSelection() {
      selectedSuggestion = null;
      btnSubmitGuess.disabled = true;
      hideSuggestions();
    }

    const CARDINAL_DIRECTIONS = [
      { name: 'N', symbol: '‚Üë' },
      { name: 'NE', symbol: '‚Üó' },
      { name: 'E', symbol: '‚Üí' },
      { name: 'SE', symbol: '‚Üò' },
      { name: 'S', symbol: '‚Üì' },
      { name: 'SW', symbol: '‚Üô' },
      { name: 'W', symbol: '‚Üê' },
      { name: 'NW', symbol: '‚Üñ' },
    ];

    function toRadians(value) {
      return (value * Math.PI) / 180;
    }

    function rhumbBearing(fromLoc, toLoc) {
      // Rhumb-line bearing is more intuitive (avoids polar shortcuts).
      const lat1 = toRadians(fromLoc.lat);
      const lat2 = toRadians(toLoc.lat);
      let deltaLon = toLoc.lon - fromLoc.lon;
      if (deltaLon > 180) {
        deltaLon -= 360;
      } else if (deltaLon < -180) {
        deltaLon += 360;
      }
      const dLonRad = toRadians(deltaLon);
      const dPhi = Math.log(Math.tan(lat2 / 2 + Math.PI / 4) / Math.tan(lat1 / 2 + Math.PI / 4));
      const bearing = Math.atan2(dLonRad, dPhi);
      return (bearing * 180 / Math.PI + 360) % 360;
    }

    const DIRECTION_BLOCKLIST = new Set(['aq']);

    function resolveLocation(cc, entryLocation) {
      return entryLocation || countryLocations[cc] || null;
    }

    function describeDirection(fromLoc, toLoc) {
      if (!fromLoc || !toLoc) return null;
      if (fromLoc.lat === toLoc.lat && fromLoc.lon === toLoc.lon) return 'Here';
      const bearing = rhumbBearing(fromLoc, toLoc);
      const index = Math.round(bearing / 45) % CARDINAL_DIRECTIONS.length;
      const entry = CARDINAL_DIRECTIONS[index];
      if (!entry) return null;
      return `${entry.name} ${entry.symbol}`;
    }

    function updateGuessPlaceholder() {
      if (!guessInput) return;
      const upcoming = Math.min(attempts + 1, MAX_GUESSES);
      const ordinal = ORDINALS[upcoming - 1] || `${upcoming}th`;
      guessInput.placeholder = `Enter your ${ordinal} guess`;
    }

    function renderGuessHistory() {
      if (!guessHistoryList) return;
      guessHistoryList.innerHTML = '';
      if (!guessHistory.length) {
        if (guessHistoryPanel) guessHistoryPanel.classList.add('hidden');
        return;
      }
      if (guessHistoryPanel) guessHistoryPanel.classList.remove('hidden');
      guessHistory.forEach((entry, index) => {
        const li = document.createElement('li');
        const info = document.createElement('div');
        info.className = 'history-info';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'history-name';
        nameSpan.textContent = `${index + 1}. ${entry.name}`;
        info.appendChild(nameSpan);
        if (entry.direction) {
          const directionSpan = document.createElement('span');
          directionSpan.className = 'history-direction';
          directionSpan.textContent = entry.direction;
          info.appendChild(directionSpan);
        }
        const status = document.createElement('span');
        status.className = `history-status ${entry.correct ? 'correct' : 'miss'}`;
        status.setAttribute('aria-label', entry.correct ? 'Correct guess' : 'Incorrect guess');
        status.textContent = entry.correct ? '‚úî' : '‚úï';
        li.appendChild(info);
        li.appendChild(status);
        guessHistoryList.appendChild(li);
        });
    }

    async function linkAccounts(sharerUid, shareeUid, sharerName, shareeName) {
      if (!firestore || !sharerUid || !shareeUid || sharerUid === shareeUid) return;
      try {
        console.log('[linkAccounts] starting', { sharerUid, shareeUid });
        await Promise.all([
          setDoc(doc(firestore, 'users', sharerUid), {
            linkedAccounts: arrayUnion(shareeUid),
          }, { merge: true }),
          setDoc(doc(firestore, 'users', shareeUid), {
            displayName: shareeName || 'Flagulous Player',
            linkedAccounts: arrayUnion(sharerUid),
          }, { merge: true }),
        ]);
        console.log('[linkAccounts] write complete', { sharerUid, shareeUid });
      } catch (err) {
        console.error('Linking accounts failed', err);
      }
    }

    function addGuessHistory(name, correct, direction, cc) {
      const entry = { name, correct, direction, cc: cc || '' };
      guessHistory.push(entry);
      if (cc) guessedThisRound.add(cc);
      renderGuessHistory();
      persistInProgressState();
    }

    function hideFullFlag() {
      if (!finalFlag) return;
      finalFlag.classList.remove('visible');
      finalFlag.removeAttribute('src');
      finalFlag.alt = '';
    }

    function showFullFlag() {
      if (!finalFlag || !pendingFullFlagSrc) return;
      finalFlag.src = pendingFullFlagSrc;
      finalFlag.alt = pendingFullFlagAlt || '';
      finalFlag.classList.add('visible');
    }

    function updateGameFinishedClass() {
      if (typeof document === 'undefined' || !document.body) return;
      document.body.classList.toggle('game-finished', roundFinished);
    }
    updateGameFinishedClass();

    function clearStage() {
      stage.querySelectorAll('.layer').forEach((layer) => layer.remove());
      colorsBox.innerHTML = '';
      visibleCount = 0;
      feedback.textContent = '';
      attempts = 0;
      awaitingGuess = false;
      roundSolved = false;
      roundFinished = false;
      updateGameFinishedClass();
      guessInput.value = '';
      resetGuessSelection();
      guessHistory = [];
      guessedThisRound = new Set();
      renderGuessHistory();
      hideFullFlag();
      pendingFullFlagSrc = '';
      pendingFullFlagAlt = '';
      updateProgress();
      updateGuessPlaceholder();
      hideShareButton();
      if (correctMessage) correctMessage.textContent = '';
      updateLayerInfo();
      setGuessRowVisible(true);
    }

    function renderSuggestions(matches) {
      if (!suggestions) return;
      suggestions.innerHTML = '';
      matches.forEach((item) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.dataset.cc = item.cc;
        button.textContent = item.name;
        suggestions.appendChild(button);
      });
      suggestions.style.display = matches.length ? 'block' : 'none';
    }

    function handleGuessInput() {
      if (!guessInput) return;
      const text = guessInput.value.trim();
      selectedSuggestion = null;
      btnSubmitGuess.disabled = true;
      hideSuggestions();
      if (text.length < GUESS_MIN_LENGTH) {
        return;
      }
      const normalized = normalizeSearchText(text);
      const exactMatch = countryOptions.find((item) => {
        const candidateName = item.name.trim();
        return normalized === item.searchName && candidateName.length === text.length;
      });
      if (exactMatch) {
        chooseSuggestion(exactMatch);
        return;
      }
      const matches = countryOptions
        .filter((item) => item.searchName.includes(normalized))
        .slice(0, SUGGESTION_LIMIT);
      if (!matches.length) {
        return;
      }
      renderSuggestions(matches);
      if (matches.length === 1 && matches[0].searchName === normalized) {
        chooseSuggestion(matches[0]);
      }
    }

    function handleSuggestionClick(event) {
      if (!suggestions || !guessInput || guessInput.disabled) return;
      const button = event.target.closest('button');
      if (!button || !suggestions.contains(button)) return;
      const cc = button.dataset.cc;
      const match = countryOptions.find((item) => item.cc === cc);
      if (!match) return;
      chooseSuggestion(match);
      guessInput.focus();
    }

    function chooseSuggestion(match) {
      if (!match) return;
      selectedSuggestion = match;
      guessInput.value = match.name;
      btnSubmitGuess.disabled = false;
      hideSuggestions();
    }

    function trySelectSingleSuggestion() {
      if (!suggestions || suggestions.style.display === 'none') return null;
      const buttons = Array.from(suggestions.querySelectorAll('button'));
      if (buttons.length !== 1) return null;
      const cc = buttons[0].dataset.cc;
      return countryOptions.find((item) => item.cc === cc) || null;
    }

    function makeRng(seed) {
      // Mulberry32 for deterministic shuffles.
      let s = seed >>> 0;
      return function rng() {
        s = (s + 0x6d2b79f5) >>> 0;
        let t = Math.imul(s ^ (s >>> 15), 1 | s);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function shuffleWithRng(arr, rng) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function buildSchedule(codes, seed) {
      if (!codes.length) return [];
      const rng = makeRng(seed);
      const picks = [];
      const pool = codes.slice();
      while (picks.length < TOTAL_WINDOW) {
        shuffleWithRng(pool, rng);
        for (const cc of pool) {
          if (picks.length >= TOTAL_WINDOW) break;
          picks.push(cc);
        }
      }
      return picks;
    }

    function updateProgress() {
      if (!progress) return;
      progress.textContent = `Guesses: ${attempts} / ${MAX_GUESSES}`;
    }

    function updateDateLabel() {
      if (!dateDisplay) return;
      if (!order.length || idx < 0) {
        dateDisplay.textContent = 'Date: ‚Äì';
        return;
      }
      const date = indexToDate(idx);
      const today = todayLocalMidnight || getLocalMidnight(new Date());
      const offset = Math.round((date.getTime() - today.getTime()) / DAY_MS);
      let suffix = `(Day ${idx + 1} of ${order.length})`;
      if (offset === 0) {
        suffix = 'Today';
      } else if (offset < 0) {
        const daysAgo = Math.abs(offset);
        suffix = `${daysAgo === 1 ? '1 day ago' : `${daysAgo} days ago`}`;
      } else {
        suffix = `${offset === 1 ? 'In 1 day' : `In ${offset} days`}`;
      }
      dateDisplay.textContent = `Date: ${formatDateLabel(date)} ‚Äî ${suffix}`;
    }

    function getDateFromUrl() {
      if (typeof window === 'undefined') return null;
      try {
        const searchParams = new URL(window.location.href).searchParams;
        const dateParam = searchParams.get('date');
        if (!dateParam) return null;
        return parseLocalDateKey(dateParam);
      } catch {
        return null;
      }
    }

    function getShareIdFromUrl() {
      if (typeof window === 'undefined') return null;
      try {
        const searchParams = new URL(window.location.href).searchParams;
        const shareId = searchParams.get(SHARE_PARAM);
        return shareId ? String(shareId).trim() : null;
      } catch {
        return null;
      }
    }

    function getIndexFromUrl() {
      if (typeof window === 'undefined') return null;
      try {
        const searchParams = new URL(window.location.href).searchParams;
        const value = searchParams.get(INDEX_PARAM);
        if (!value) return null;
        const parsed = Number.parseInt(value, 10);
        return Number.isNaN(parsed) ? null : parsed;
      } catch {
        return null;
      }
    }

    function getArchiveParamFromUrl() {
      if (typeof window === 'undefined') return false;
      try {
        const searchParams = new URL(window.location.href).searchParams;
        return searchParams.get(ARCHIVE_PARAM) === '1';
      } catch {
        return false;
      }
    }

    function persistPendingShareId(value) {
      if (!value || typeof localStorage === 'undefined') return;
      try {
        localStorage.setItem(SHARE_PENDING_KEY, value);
      } catch (err) {
        console.error('Persisting pending share link failed', err);
      }
    }

    function loadPendingShareId() {
      if (typeof localStorage === 'undefined') return null;
      try {
        const stored = localStorage.getItem(SHARE_PENDING_KEY);
        return stored ? String(stored).trim() : null;
      } catch (err) {
        console.error('Loading pending share link failed', err);
        return null;
      }
    }

    function clearPendingShareId() {
      if (typeof localStorage === 'undefined') return;
      try {
        localStorage.removeItem(SHARE_PENDING_KEY);
      } catch (err) {
        console.error('Clearing pending share link failed', err);
      }
    }

    function captureShareIdFromUrl() {
      if (typeof window === 'undefined' || !window.history) return;
      const shareId = getShareIdFromUrl();
      if (!shareId) return;
      persistPendingShareId(shareId);
      try {
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete(SHARE_PARAM);
        window.history.replaceState(null, '', currentUrl.toString());
      } catch {
        // ignore
      }
    }

    async function processPendingShareLink() {
      const shareId = loadPendingShareId();
      if (!shareId || !firebaseUser) return;
      const linked = await linkShareToAccount(shareId);
      if (linked) {
        clearPendingShareId();
      }
    }

    async function linkShareToAccount(shareId) {
      if (!shareId || !firebaseUser || shareLinkInProgress) return false;
      shareLinkInProgress = true;
      try {
        const shareRef = doc(firestore, 'shares', shareId);
        const snap = await getDoc(shareRef);
        if (!snap.exists()) {
          console.warn('Share link not found', shareId);
          return false;
        }
        const shareData = snap.data() || {};
        console.log('[share] linking', { shareId, shareData, uid: firebaseUser.uid });
        if (!shareData.sharerUid || shareData.sharerUid === firebaseUser.uid) {
          setShareLinkMessage('Share already belongs to you.');
          return true;
        }
        const connectionRef = doc(firestore, 'shares', shareId, 'connections', firebaseUser.uid);
        const connectionSnap = await getDoc(connectionRef);
        let isNewConnection = false;
        if (!connectionSnap.exists()) {
          isNewConnection = true;
          await setDoc(connectionRef, {
            shareId,
            shareeUid: firebaseUser.uid,
            linkedAt: serverTimestamp(),
            sharerUid: shareData.sharerUid,
            sharerName: shareData.sharerName || null,
            date: shareData.date || null,
            attempts: shareData.attempts || null,
          });
          await updateDoc(shareRef, { shareeCount: increment(1) });
          if (shareData.sharerUid) {
            await setDoc(doc(firestore, 'shareStats', shareData.sharerUid), {
              displayName: shareData.sharerName || '',
              shareeCount: increment(1),
            }, { merge: true });
          }
          const shareeStatsRef = doc(firestore, 'shareStats', firebaseUser.uid);
          const shareeName = firebaseUser.displayName || firebaseUser.email || 'Flagulous Player';
          await setDoc(shareeStatsRef, {
            displayName: shareeName,
            shareeCount: increment(1),
          }, { merge: true });
        }
        const shareeName = firebaseUser.displayName || firebaseUser.email || 'Flagulous Player';
        if (shareData.sharerUid) {
          const sharerName = shareData.sharerName || 'Flagulous Player';
          await linkAccounts(shareData.sharerUid, firebaseUser.uid, sharerName, shareeName);
        }
        setShareLinkMessage(isNewConnection
          ? `Connected to ${shareData.sharerName || 'your sharer'}!`
          : `Already connected to ${shareData.sharerName || 'that sharer'}.`);
        return true;
      } catch (err) {
        console.error('Linking share failed', err);
        return false;
      } finally {
        shareLinkInProgress = false;
      }
    }

    function updateUrlWithDate(date) {
      if (!date || typeof window === 'undefined' || !window.history) return;
      try {
        const iso = formatIsoDateKey(date);
        if (!iso) return;
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('date', iso);
        const todayIso = formatIsoDateKey(todayLocalMidnight || getLocalMidnight(new Date()));
        if (iso !== todayIso) {
          currentUrl.searchParams.set(ARCHIVE_PARAM, '1');
        } else {
          currentUrl.searchParams.delete(ARCHIVE_PARAM);
        }
        window.history.replaceState(null, '', currentUrl.toString());
      } catch (err) {
        console.error('Updating URL failed', err);
      }
    }

    function updateNavButtons() {
      if (!btnPrevDate || !btnNextDate) return;
      if (!order.length) {
        btnPrevDate.disabled = true;
        btnNextDate.disabled = true;
        return;
      }
      btnPrevDate.disabled = idx <= 0;
      const maxIdx = Math.min(order.length - 1, TODAY_INDEX);
      btnNextDate.disabled = idx >= maxIdx;
    }

    function setGuessControls(enabled) {
      guessInput.disabled = !enabled;
      if (!enabled) {
        guessInput.value = '';
      }
      resetGuessSelection();
    }

    function setGiveUp(enabled) {
      btnGiveUp.disabled = !enabled;
    }

    function setGuessRowVisible(visible) {
      if (!guessRow) return;
      if (roundFinished && visible) {
        guessRow.hidden = true;
        return;
      }
      guessRow.hidden = !visible;
    }

    function revealLayer(force = false) {
      if (!current) return;
      if (!force && awaitingGuess) return;
      const layers = stage.querySelectorAll('.layer');
      if (visibleCount >= layers.length) {
        return;
      }
      layers[visibleCount].classList.add('visible');
      visibleCount++;
      awaitingGuess = true;
      updateProgress();
      updateLayerInfo();
    }

    function endRound(wasCorrect = false) {
      awaitingGuess = false;
      roundFinished = true;
      roundSolved = !!wasCorrect;
      updateGameFinishedClass();
      const layers = stage.querySelectorAll('.layer');
      layers.forEach(l => l.classList.add('visible'));
      visibleCount = layers.length;
      setGuessControls(false);
      setGiveUp(false);
      updateProgress();
      showFullFlag();
      updateLayerInfo();
      if (btnGiveUp) {
        btnGiveUp.hidden = true;
      }
      showLeaderboardLink(true);
      setGuessRowVisible(false);
    }

    function submitGuess() {
      if (!current || guessInput.disabled) return;
      if (!selectedSuggestion) {
        feedback.textContent = 'Select a country from the suggestions before submitting.';
        return;
      }
      if (guessInput && shouldBlurAfterGuess()) {
        guessInput.blur();
      }
      if (guessedThisRound.has(selectedSuggestion.cc)) {
        feedback.textContent = `You already guessed ${selectedSuggestion.name}. Try a different country.`;
        guessInput.value = '';
        resetGuessSelection();
        return;
      }
      guessedThisRound.add(selectedSuggestion.cc);
      attempts++;
      updateGuessPlaceholder();
      const name = isoToName(current.cc);
      const correct = selectedSuggestion.cc === current.cc;
      const guessLocation = resolveLocation(selectedSuggestion.cc, selectedSuggestion.location);
      const targetLocation = resolveLocation(current.cc, current.location);
      const directionHint = !correct && !DIRECTION_BLOCKLIST.has(selectedSuggestion.cc)
        ? describeDirection(guessLocation, targetLocation)
        : null;
      addGuessHistory(selectedSuggestion.name, correct, directionHint, selectedSuggestion.cc);
      if (correct) {
      feedback.textContent = '';
        if (correctMessage) {
          correctMessage.textContent = `CORRECT! It was ${name}`;
        }
        triggerFireworks();
        const currentDate = order.length && idx >= 0 ? indexToDate(idx) : new Date();
        const dateLabel = currentDate ? formatDateLabel(currentDate) : 'today';
        const dateKey = formatLocalDateKey(currentDate);
        const sharePayload = buildSharePayload(attempts, dateLabel, dateKey, idx);
        showShareButton(sharePayload);
        saveGameResultToAccount('solved');
        updateProgress();
        endRound(true);
        resetGuessSelection();
        guessInput.value = '';
        return;
      }
      if (attempts >= MAX_GUESSES) {
      feedback.textContent = '';
      setUnderFlagMessage(`OUT OF GUESSES. THE FLAG WAS ${name}`);
      saveGameResultToAccount('failed');
      endRound(false);
      hideShareButton();
      resetGuessSelection();
      guessInput.value = '';
      return;
    }
      feedback.textContent = 'Not quite ‚Äî here is another layer.';
      flashMobileTryAgain();
      guessInput.value = '';
      resetGuessSelection();
      const layers = stage.querySelectorAll('.layer');
      if (visibleCount < layers.length) {
        awaitingGuess = false;
        revealLayer(true);
      }
      updateProgress();
      if (guessInput && !shouldBlurAfterGuess()) {
        guessInput.focus();
      }
    }

    function giveUp() {
      if (!current || btnGiveUp.disabled) return;
      const name = isoToName(current.cc);
      feedback.textContent = `Revealed: ${name}.`;
      attempts = MAX_GUESSES;
      saveGameResultToAccount('gave-up');
      updateProgress();
      endRound(false);
      hideShareButton();
    }

    function restartLayers() {
      if (!current) return;
      hideFullFlag();
      const layers = stage.querySelectorAll('.layer');
      layers.forEach(l => l.classList.remove('visible'));
      visibleCount = 0;
      awaitingGuess = false;
      attempts = 0;
      guessedThisRound = new Set();
      feedback.textContent = '';
      guessInput.value = '';
      roundFinished = false;
      roundSolved = false;
      updateGameFinishedClass();
      setUnderFlagMessage('');
      if (correctMessage) correctMessage.textContent = '';
      setGuessControls(true);
      setGiveUp(true);
      if (btnGiveUp) btnGiveUp.hidden = false;
      setGuessRowVisible(true);
      setGuessRowVisible(true);
      if (btnGiveUp) btnGiveUp.hidden = false;
      if (btnGiveUp) btnGiveUp.hidden = false;
      hideShareButton();
      updateGuessPlaceholder();
      revealLayer(true);
      updateProgress();
      updateLayerInfo();
    }

    function loadFlag(cc, { focusGuess = true } = {}) {
      clearStage();
      current = { cc, ...manifest[cc] };
      current.location = current.location || countryLocations[cc] || null;
      if (current.full) {
        pendingFullFlagSrc = `/output/${cc}/${current.full}`;
        pendingFullFlagAlt = isoToName(cc);
        const prefetch = new Image();
        prefetch.src = pendingFullFlagSrc;
      } else {
        pendingFullFlagSrc = '';
        pendingFullFlagAlt = '';
      }
      if (finalFlag) {
        hideFullFlag();
      }
      if (!current.files || current.files.length === 0) {
        feedback.textContent = 'No layers found for this flag.';
        setGuessControls(false);
        setGiveUp(false);
        updateDateLabel();
        updateNavButtons();
        return;
      }
      const zOrder = current.z || [];
      current.files.forEach((file, i) => {
        const img = document.createElement('img');
        img.className = 'layer';
        img.decoding = 'async';
        img.loading = 'eager';
        img.src = `/output/${cc}/${file}`;
        const z = zOrder[i] ?? i;
        img.style.zIndex = String(z);
        stage.appendChild(img);
      });

      const uniqueColors = Array.from(new Set(current.colors));
      uniqueColors.forEach(hex => {
        const sw = document.createElement('div');
        sw.className = 'swatch';
        sw.style.background = hex;
        colorsBox.appendChild(sw);
      });

      setGuessControls(true);
      setGiveUp(true);
      guessInput.value = '';
      if (focusGuess) {
        guessInput.focus();
      }
      updateProgress();
      showLeaderboardLink(false);
      updateDateLabel();
      updateNavButtons();
      revealLayer(true);
      updateProgress();
      applySavedResult();
    }

    function goToIndex(newIndex, options = {}) {
      if (order.length === 0) return;
      idx = clampIndex(newIndex);
      const cc = order[idx];
      loadFlag(cc, options);
      const currentDate = indexToDate(idx);
      updateUrlWithDate(currentDate);
      persistLastViewedDate(currentDate);
      persistLastViewedIndex(idx);
    }

    function nextFlag() {
      if (order.length === 0) return;
      const maxIdx = Math.min(order.length - 1, TODAY_INDEX);
      if (idx >= maxIdx) return;
      goToIndex(idx + 1, { focusGuess: false });
    }

    function prevFlag() {
      if (order.length === 0) return;
      goToIndex(idx - 1, { focusGuess: false });
    }

    btnSubmitGuess.addEventListener('click', submitGuess);
    guessInput.addEventListener('input', handleGuessInput);
    guessInput.addEventListener('keydown', (evt) => {
      if (evt.key !== 'Enter') return;
      evt.preventDefault();
      if (!selectedSuggestion && suggestions && suggestions.style.display !== 'none') {
        const buttons = Array.from(suggestions.querySelectorAll('button'));
        if (buttons.length > 1) {
          const cc = buttons[0].dataset.cc;
          const match = countryOptions.find((item) => item.cc === cc);
          if (match) chooseSuggestion(match);
        } else {
          const single = trySelectSingleSuggestion();
          if (single) {
            chooseSuggestion(single);
          }
        }
      }
      submitGuess();
    });
    if (suggestions) {
      suggestions.addEventListener('click', handleSuggestionClick);
    }
    document.addEventListener('click', (event) => {
      if (autosuggest && !autosuggest.contains(event.target) && suggestions && !suggestions.contains(event.target)) {
        hideSuggestions();
      }
    });
    document.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowLeft' && document.activeElement !== guessInput) {
        event.preventDefault();
        prevFlag();
      } else if (event.key === 'ArrowRight' && document.activeElement !== guessInput) {
        event.preventDefault();
        nextFlag();
      }
    });
    btnGiveUp.addEventListener('click', giveUp);
    btnPrevDate.addEventListener('click', prevFlag);
    if (btnNextDate) btnNextDate.addEventListener('click', nextFlag);
    if (btnShare) btnShare.addEventListener('click', shareResults);
    if (leaderboardLink) {
      leaderboardLink.addEventListener('click', () => {
        const currentDate = indexToDate(idx);
        const iso = currentDate ? formatLocalDateKey(currentDate) : formatLocalDateKey(new Date());
        const todayIso = formatIsoDateKey(todayLocalMidnight || getLocalMidnight(new Date()));
        const params = new URLSearchParams();
        if (iso) params.set('date', iso);
        if (iso && todayIso && iso !== todayIso) {
          params.set('archive', '1');
        }
        params.set('highlight', '1');
        window.location.href = `/profile.html?${params.toString()}`;
      });
    }

    function preventMobileScrollOnFocus() {
      if (!guessInput) return;
      const handler = () => {
        if (window.matchMedia('(max-width: 720px)').matches) {
          setTimeout(() => window.scrollTo(0, 0), 100);
        }
      };
      guessInput.addEventListener('focus', handler);
    }

    async function boot() {
      const res = await fetch('/api/manifest');
      manifest = await res.json();
      try {
        const locRes = await fetch('/data/country-locations.json');
        if (locRes.ok) {
          countryLocations = await locRes.json();
        }
      } catch {
        countryLocations = {};
      }

      const validCountries = Object.keys(manifest).filter(cc => (manifest[cc].files || []).length > 0);
      countryOptions = validCountries.map((cc) => {
        const entry = manifest[cc] || {};
        const name = isoToName(cc);
        return {
          cc,
          name,
          searchName: normalizeSearchText(name),
          location: entry.location || countryLocations[cc] || null,
        };
      })
        .sort((a, b) => a.name.localeCompare(b.name));

      const scheduleCodes = [...validCountries].sort((a, b) => a.localeCompare(b));
      todayLocalMidnight = getLocalMidnight(new Date());
      startDate = new Date(todayLocalMidnight.getTime() - DAYS_BEFORE * DAY_MS);
      order = buildSchedule(scheduleCodes, SCHEDULE_SEED_VALUE);

      if (!order.length) {
        updateDateLabel();
        updateNavButtons();
        return;
      }

      const archiveParam = getArchiveParamFromUrl();
      const shouldHonorRequestedDate = archiveParam || Boolean(initialShareId);
      const requestedDate = shouldHonorRequestedDate ? getDateFromUrl() : null;
      const requestedIndex = shouldHonorRequestedDate ? getIndexFromUrl() : null;
      const resolvedIndex = shouldHonorRequestedDate
        ? requestedIndex ?? (requestedDate ? dateDiffInDays(requestedDate) : null)
        : null;
      const todayIso = formatIsoDateKey(todayLocalMidnight || getLocalMidnight(new Date()));
      let savedIndex = null;
      if (!shouldHonorRequestedDate) {
        const savedDate = loadLastViewedDate();
        const savedDateIso = savedDate ? formatIsoDateKey(savedDate) : null;
        if (savedDateIso === todayIso) {
          savedIndex = loadLastViewedIndex();
        }
      }
      idx = clampIndex(resolvedIndex ?? savedIndex ?? TODAY_INDEX);
      goToIndex(idx);
      updateNavButtons();
    }

    initialShareId = getShareIdFromUrl();
    captureShareIdFromUrl();
    boot();
    preventMobileScrollOnFocus();
  </script>
</body>
</html>
